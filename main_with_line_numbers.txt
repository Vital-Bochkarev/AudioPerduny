     1	import os
     2	import logging
     3	import asyncio
     4	import json
     5	from uuid import uuid4
     6	from telegram import Update, InlineQueryResultCachedVoice, InlineQueryResultCachedAudio, InlineKeyboardMarkup, InlineKeyboardButton
     7	from telegram.ext import (
     8	    Application,
     9	    CommandHandler,
    10	    MessageHandler,
    11	    CallbackQueryHandler, # New: for handling button presses
    12	    filters,
    13	    InlineQueryHandler,
    14	    ContextTypes
    15	)
    16	from aiohttp import web
    17	
    18	# Configure logging
    19	logging.basicConfig(
    20	    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    21	    level=logging.INFO
    22	)
    23	logger = logging.getLogger(__name__)
    24	
    25	# Configuration
    26	AUDIO_STORAGE = 'audio_messages' # This is the mounted persistent volume path
    27	TOKEN = os.getenv('BOT_TOKEN')
    28	HEALTH_CHECK_PORT = 8080
    29	AUDIO_METADATA_FILE = os.path.join(AUDIO_STORAGE, 'audio_metadata.json')
    30	AUDIOS_PER_PAGE = 5 # Changed from 10 to 5 audios per page
    31	
    32	# New: Authorized users list
    33	# Get AUTHORIZED_USERS from environment variable, split by comma, and convert to integers.
    34	# If not set, default to an empty list (no one authorized by default).
    35	# Example: AUTHORIZED_USERS="123456789,987654321"
    36	AUTHORIZED_USERS_STR = os.getenv('AUTHORIZED_USERS')
    37	AUTHORIZED_USERS = [int(uid.strip()) for uid in AUTHORIZED_USERS_STR.split(',') if uid.strip()] if AUTHORIZED_USERS_STR else []
    38	
    39	# Global variable to hold cached audio data
    40	cached_audios_data = []
    41	
    42	# --- Persistence Functions (File-based) ---
    43	
    44	def load_audio_metadata():
    45	    """Loads audio metadata from the JSON file on the persistent volume."""
    46	    global cached_audios_data
    47	    if os.path.exists(AUDIO_METADATA_FILE):
    48	        try:
    49	            with open(AUDIO_METADATA_FILE, 'r', encoding='utf-8') as f:
    50	                cached_audios_data = json.load(f)
    51	            logger.info(f"Loaded {len(cached_audios_data)} audio entries from {AUDIO_METADATA_FILE}")
    52	        except json.JSONDecodeError as e:
    53	            logger.error(f"Error decoding JSON from {AUDIO_METADATA_FILE}: {e}")
    54	            cached_audios_data = [] # Reset if file is corrupt
    55	        except Exception as e:
    56	            logger.error(f"Error loading audio metadata: {e}")
    57	            cached_audios_data = []
    58	    else:
    59	        logger.info("Audio metadata file not found. Starting with empty data.")
    60	        cached_audios_data = []
    61	
    62	def save_audio_metadata():
    63	    """Saves audio metadata to the JSON file on the persistent volume."""
    64	    try:
    65	        with open(AUDIO_METADATA_FILE, 'w', encoding='utf-8') as f:
    66	            json.dump(cached_audios_data, f, ensure_ascii=False, indent=4)
    67	        logger.info(f"Saved {len(cached_audios_data)} audio entries to {AUDIO_METADATA_FILE}")
    68	    except Exception as e:
    69	        logger.error(f"Error saving audio metadata: {e}")
    70	
    71	# --- Telegram Bot Handlers ---
    72	
    73	async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    74	    """Sends a welcome message when the /start command is issued, with authorization check."""
    75	    user_id = update.effective_user.id
    76	    if AUTHORIZED_USERS and user_id not in AUTHORIZED_USERS:
    77	        # Message for unauthorized users
    78	        await update.message.reply_text(
    79	            "–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é. –ß—Ç–æ–±—ã –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º, –≤ –ª—é–±–æ–º —á–∞—Ç–µ –Ω–∞–±–µ—Ä–∏ @Perduny_bot –∏ –≤—ã–±–µ—Ä–∏ –≥–æ–ª–æ—Å–æ–≤–æ–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.\n"
    80	            "–û—Ç–ø—Ä–∞–≤—å –≤ —ç—Ç–æ—Ç —á–∞—Ç /voices, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –≥–æ–ª–æ—Å–æ–≤—ã–µ.\n"
    81	            "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏ —É–¥–∞–ª–µ–Ω–∏–µ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
    82	        )
    83	        logger.info(f"Unauthorized user {user_id} started the bot.")
    84	    else:
    85	        # Existing welcome message for authorized users, now with command suggestions
    86	        await update.message.reply_text(
    87	            "üé§ –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ —É–ø—Ä–∞–≤–ª—è—Ç—å –≥–æ–ª–æ—Å–æ–≤—ã–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏.\n\n"
    88	            "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
    89	            "/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –∞—É–¥–∏–æ\n"
    90	            "/list - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∞—É–¥–∏–æ\n"
    91	            "/delete <ID> - –£–¥–∞–ª–∏—Ç—å –∞—É–¥–∏–æ –ø–æ ID\n"
    92	            "/move <ID> <–ø–æ–∑–∏—Ü–∏—è> - –ò–∑–º–µ–Ω–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫ –∞—É–¥–∏–æ\n"
    93	            "/edit <ID> - –ò–∑–º–µ–Ω–∏—Ç—å –∞–≤—Ç–æ—Ä–∞ –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ\n"
    94	            "/voices - –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∞—É–¥–∏–æ"
    95	        )
    96	        logger.info(f"Authorized user {user_id} started the bot.")
    97	
    98	async def add_audio_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    99	    """Initiates the audio adding process for authorized users."""
   100	    user = update.effective_user
   101	    if AUTHORIZED_USERS and user.id not in AUTHORIZED_USERS:
   102	        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
   103	        logger.warning(f"Unauthorized attempt to use /add by user: {user.id}")
   104	        return
   105	    
   106	    context.user_data['state'] = 'awaiting_audio_for_add'
   107	    await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –∞—É–¥–∏–æ —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä–æ–µ —Ç—ã —Ö–æ—á–µ—à—å –¥–æ–±–∞–≤–∏—Ç—å.")
   108	    logger.info(f"User {user.id} initiated /add command.")
   109	
   110	
   111	async def list_audios_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   112	    """Lists all saved audio files (admin-only)."""
   113	    global cached_audios_data
   114	    
   115	    user_id = update.effective_user.id
   116	    if AUTHORIZED_USERS and user_id not in AUTHORIZED_USERS:
   117	        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
   118	        logger.warning(f"Unauthorized attempt to list audios by user: {user_id}")
   119	        return
   120	
   121	    if not cached_audios_data:
   122	        await update.message.reply_text("–ü–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∞—É–¥–∏–æ.")
   123	        return
   124	
   125	    message_text = "–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∞—É–¥–∏–æ:\n\n"
   126	    for i, item in enumerate(cached_audios_data):
   127	        # Using the file_id as the unique identifier for deletion
   128	        message_text += f"{i+1}. ID: `{item.get('file_id', 'N/A')}`\n" \
   129	                        f"   –ê–≤—Ç–æ—Ä: {item.get('author', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä')}\n" \
   130	                        f"   –ù–∞–∑–≤–∞–Ω–∏–µ: {item.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}\n\n"
   131	    
   132	    await update.message.reply_text(message_text, parse_mode='Markdown')
   133	
   134	async def delete_audio_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   135	    """Deletes a saved audio file by its file_id (admin-only)."""
   136	    global cached_audios_data
   137	    
   138	    # Authorization check for delete command
   139	    user_id = update.effective_user.id
   140	    if AUTHORIZED_USERS and user_id not in AUTHORIZED_USERS:
   141	        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
   142	        logger.warning(f"Unauthorized attempt to delete audio by user: {user_id}")
   143	        return
   144	
   145	    if not context.args:
   146	        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ ID –∞—É–¥–∏–æ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /list, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ ID.")
   147	        return
   148	    
   149	    audio_id_to_delete = context.args[0].strip()
   150	    logger.info(f"Attempting to delete audio with ID: '{audio_id_to_delete}' by user: {user_id}")
   151	    
   152	    original_count = len(cached_audios_data)
   153	    
   154	    new_cached_audios_data = []
   155	    found_and_deleted = False
   156	    for item in cached_audios_data:
   157	        current_file_id = item.get('file_id')
   158	        logger.info(f"Comparing '{audio_id_to_delete}' with existing ID: '{current_file_id}'")
   159	        if current_file_id == audio_id_to_delete:
   160	            found_and_deleted = True
   161	            logger.info(f"Match found! Deleting audio: {item.get('name')} by {item.get('author')}")
   162	        else:
   163	            new_cached_audios_data.append(item)
   164	            
   165	    cached_audios_data = new_cached_audios_data # Update the global list
   166	
   167	    if found_and_deleted:
   168	        save_audio_metadata() # Save changes to the file
   169	        await update.message.reply_text(f"–ê—É–¥–∏–æ —Å ID `{audio_id_to_delete}` —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ.")
   170	        logger.info(f"Audio with ID {audio_id_to_delete} deleted by user {update.effective_user.id}.")
   171	    else:
   172	        await update.message.reply_text(f"–ê—É–¥–∏–æ —Å ID `{audio_id_to_delete}` –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å ID.")
   173	        logger.warning(f"Attempted to delete non-existent audio with ID {audio_id_to_delete} by user {user_id}.")
   174	
   175	async def move_audio_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   176	    """Moves a saved audio file to a new position (admin-only)."""
   177	    global cached_audios_data
   178	
   179	    user_id = update.effective_user.id
   180	    if AUTHORIZED_USERS and user_id not in AUTHORIZED_USERS:
   181	        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
   182	        logger.warning(f"Unauthorized attempt to move audio by user: {user_id}")
   183	        return
   184	
   185	    if len(context.args) != 2:
   186	        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /move <ID_–∞—É–¥–∏–æ> <–Ω–æ–≤–∞—è_–ø–æ–∑–∏—Ü–∏—è>\n"
   187	                                        "–ü—Ä–∏–º–µ—Ä: /move AwACAgQAAxk... 3")
   188	        return
   189	
   190	    audio_id_to_move = context.args[0].strip()
   191	    try:
   192	        new_position = int(context.args[1])
   193	    except ValueError:
   194	        await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏. –ü–æ–∑–∏—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
   195	        return
   196	
   197	    if not cached_audios_data:
   198	        await update.message.reply_text("–°–ø–∏—Å–æ–∫ –∞—É–¥–∏–æ –ø—É—Å—Ç. –ù–µ—á–µ–≥–æ –ø–µ—Ä–µ–º–µ—â–∞—Ç—å.")
   199	        return
   200	
   201	    # Find the audio to move
   202	    audio_to_move = None
   203	    original_index = -1
   204	    for i, item in enumerate(cached_audios_data):
   205	        if item.get('file_id') == audio_id_to_move: # Corrected variable name
   206	            audio_to_move = item # Corrected variable name
   207	            original_index = i # Store original index
   208	            break
   209	
   210	    if audio_to_move is None: # Corrected variable name
   211	        await update.message.reply_text(f"–ê—É–¥–∏–æ —Å ID `{audio_id_to_move}` –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.") # Corrected variable name
   212	        logger.warning(f"Attempted to move non-existent audio with ID {audio_id_to_move} by user {user_id}.") # Corrected variable name
   213	        return
   214	
   215	    # Adjust new_position to be 0-indexed and within bounds
   216	    # User provides 1-indexed position, convert to 0-indexed
   217	    target_index = new_position - 1
   218	    
   219	    # Ensure target_index is within valid range [0, len(list)]
   220	    # len(list) is a valid index for inserting at the very end
   221	    if not (0 <= target_index <= len(cached_audios_data) - 1): # Allow inserting at the end
   222	        await update.message.reply_text(f"–ù–µ–≤–µ—Ä–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø–æ–∑–∏—Ü–∏—é –æ—Ç 1 –¥–æ {len(cached_audios_data)}.")
   223	        return
   224	
   225	    # Remove the audio from its original position
   226	    cached_audios_data.pop(original_index)
   227	
   228	    # Insert the audio at the new position
   229	    cached_audios_data.insert(target_index, audio_to_move)
   230	
   231	    save_audio_metadata() # Save changes to the file
   232	    await update.message.reply_text(f"–ê—É–¥–∏–æ '{audio_to_move.get('name')}' –ø–µ—Ä–µ–º–µ—â–µ–Ω–æ –Ω–∞ –ø–æ–∑–∏—Ü–∏—é {new_position}.")
   233	    logger.info(f"Audio '{audio_to_move.get('name')}' (ID: {audio_id_to_move}) moved from {original_index} to {target_index} by user {user_id}.")
   234	
   235	async def edit_audio_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   236	    """Initiates the audio editing process for authorized users."""
   237	    user = update.effective_user
   238	    if AUTHORIZED_USERS and user.id not in AUTHORIZED_USERS:
   239	        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
   240	        logger.warning(f"Unauthorized attempt to use /edit by user: {user.id}")
   241	        return
   242	
   243	    if not context.args:
   244	        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ ID –∞—É–¥–∏–æ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /list, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ ID.")
   245	        return
   246	    
   247	    audio_id_to_edit = context.args[0].strip()
   248	    
   249	    # Find the audio to edit
   250	    found_audio = None
   251	    for item in cached_audios_data:
   252	        if item.get('file_id') == audio_id_to_edit:
   253	            found_audio = item
   254	            break
   255	
   256	    if found_audio is None:
   257	        await update.message.reply_text(f"–ê—É–¥–∏–æ —Å ID `{audio_id_to_edit}` –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
   258	        logger.warning(f"Attempted to edit non-existent audio with ID {audio_id_to_edit} by user {user.id}.")
   259	        return
   260	
   261	    context.user_data['state'] = 'awaiting_new_author'
   262	    context.user_data['editing_audio_id'] = audio_id_to_edit
   263	    await update.message.reply_text(f"–ù–∞–π–¥–µ–Ω–æ –∞—É–¥–∏–æ '{found_audio.get('name')}' –æ—Ç '{found_audio.get('author')}'.\n"
   264	                                    f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–≥–æ –∞–≤—Ç–æ—Ä–∞ –¥–ª—è —ç—Ç–æ–≥–æ –∞—É–¥–∏–æ:")
   265	    logger.info(f"User {user.id} initiated /edit command for audio ID: {audio_id_to_edit}")
   266	
   267	
   268	async def handle_audio(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   269	    """Handles incoming voice messages and audio files."""
   270	    user = update.effective_user
   271	
   272	    # Authorization check for adding audio
   273	    if AUTHORIZED_USERS and user.id not in AUTHORIZED_USERS:
   274	        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∞—É–¥–∏–æ.")
   275	        logger.warning(f"Unauthorized attempt to add audio by user: {user.id}")
   276	        return
   277	
   278	    # New: Check if the user is in the 'awaiting_audio_for_add' state
   279	    if context.user_data.get('state') != 'awaiting_audio_for_add':
   280	        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /add, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –∞—É–¥–∏–æ.")
   281	        logger.info(f"User {user.id} sent audio without /add command.")
   282	        return
   283	
   284	    file_id = None
   285	    file_type = None
   286	    duration = 0
   287	
   288	    if update.message.voice:
   289	        file_id = update.message.voice.file_id
   290	        file_type = "voice"
   291	        duration = update.message.voice.duration
   292	        logger.info(f"Received voice message from {user.first_name} ({user.id})")
   293	    elif update.message.audio:
   294	        file_id = update.message.audio.file_id
   295	        file_type = "audio"
   296	        duration = update.message.audio.duration
   297	        logger.info(f"Received audio file from {user.first_name} ({user.id})")
   298	    else:
   299	        await update.message.reply_text("–Ø –º–æ–≥—É –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–ª–∏ .ogg —Ñ–∞–π–ª—ã —Å –∫–æ–¥–µ–∫–æ–º opus")
   300	        return
   301	
   302	    if file_id:
   303	        context.user_data['pending_audio_file_id'] = file_id
   304	        context.user_data['pending_audio_file_type'] = file_type
   305	        # Change the initial state to awaiting_author_name
   306	        context.user_data['state'] = 'awaiting_author_name'
   307	        logger.info(f"User {user.id} sent a {file_type} and is now awaiting author name.")
   308	        # Change the initial prompt to ask for author
   309	        await update.message.reply_text("–ü–æ–ª—É—á–∏–ª –≥–æ–ª–æ—Å–æ–≤–æ–µ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –∞–≤—Ç–æ—Ä–∞")
   310	
   311	async def handle_text_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   312	    """Handles text input based on the current state of the conversation."""
   313	    user = update.effective_user
   314	    current_state = context.user_data.get('state')
   315	
   316	    # Handle author input for adding new audio
   317	    if current_state == 'awaiting_author_name':
   318	        author_name = update.message.text.strip()
   319	        if author_name:
   320	            context.user_data['temp_author_name'] = author_name # Store author temporarily
   321	            context.user_data['state'] = 'awaiting_audio_name' # Move to next state
   322	            logger.info(f"User {user.id} provided author name: '{author_name}'. Now awaiting audio name.")
   323	            await update.message.reply_text("–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞")
   324	        else:
   325	            await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –∞–≤—Ç–æ—Ä–∞.")
   326	    
   327	    # Handle audio name input for adding new audio
   328	    elif current_state == 'awaiting_audio_name':
   329	        audio_name = update.message.text.strip()
   330	        file_id = context.user_data.pop('pending_audio_file_id', None)
   331	        file_type = context.user_data.pop('pending_audio_file_type', None)
   332	        author_name = context.user_data.pop('temp_author_name', None) # Retrieve author
   333	        context.user_data.pop('state', None) # Clear the state
   334	
   335	        if audio_name and file_id and file_type and author_name:
   336	            # Store the audio details in the global list
   337	            global cached_audios_data
   338	            cached_audios_data.append({
   339	                'name': audio_name,
   340	                'author': author_name,
   341	                'file_id': file_id,
   342	                'type': file_type,
   343	                'telegram_user_id': user.id, # Store the actual Telegram user ID for reference
   344	            })
   345	            save_audio_metadata() # Save to file immediately after adding
   346	            logger.info(f"Saved {file_type} '{audio_name}' by '{author_name}' (ID: {file_id}) to persistent file for user {user.id}.")
   347	            await update.message.reply_text(
   348	                f"–°–æ—Ö—Ä–∞–Ω–∏–ª —Ç–≤–æ–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ –∫–∞–∫ '{audio_name}' –æ—Ç '{author_name}'! "
   349	                "–ú–æ–∂–µ—à—å —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ—Å—ã–ª–∞—Ç—å –µ–≥–æ –≤ —á–∞—Ç–µ, —É–∫–∞–∑–∞–≤ –∏–º—è –±–æ—Ç–∞ —á–µ—Ä–µ–∑ @"
   350	            )
   351	        else:
   352	            logger.warning(f"User {user.id} provided audio name '{audio_name}' but missing other audio details.")
   353	            await update.message.reply_text("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –ø–æ–≤—Ç–æ—Ä–∏ —Å –Ω–∞—á–∞–ª–∞")
   354	    
   355	    # Handle new author input for editing existing audio
   356	    elif current_state == 'awaiting_new_author':
   357	        new_author = update.message.text.strip()
   358	        if new_author:
   359	            context.user_data['temp_new_author'] = new_author
   360	            context.user_data['state'] = 'awaiting_new_name'
   361	            await update.message.reply_text("–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –∞—É–¥–∏–æ:")
   362	            logger.info(f"User {user.id} provided new author: '{new_author}' for editing audio.")
   363	        else:
   364	            await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–≥–æ –∞–≤—Ç–æ—Ä–∞.")
   365	    
   366	    # Handle new name input for editing existing audio
   367	    elif current_state == 'awaiting_new_name':
   368	        new_name = update.message.text.strip()
   369	        audio_id_to_edit = context.user_data.pop('editing_audio_id', None)
   370	        new_author = context.user_data.pop('temp_new_author', None)
   371	        context.user_data.pop('state', None) # Clear the state
   372	
   373	        if new_name and audio_id_to_edit and new_author:
   374	            global cached_audios_data
   375	            found_and_updated = False
   376	            for item in cached_audios_data:
   377	                if item.get('file_id') == audio_id_to_edit:
   378	                    item['author'] = new_author
   379	                    item['name'] = new_name
   380	                    found_and_updated = True
   381	                    break
   382	            
   383	            if found_and_updated:
   384	                save_audio_metadata()
   385	                await update.message.reply_text(f"–ê—É–¥–∏–æ —Å ID `{audio_id_to_edit}` —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ:\n"
   386	                                                f"–ù–æ–≤—ã–π –ê–≤—Ç–æ—Ä: {new_author}\n"
   387	                                                f"–ù–æ–≤–æ–µ –ù–∞–∑–≤–∞–Ω–∏–µ: {new_name}")
   388	                logger.info(f"Audio ID {audio_id_to_edit} updated by user {user.id} to Author: '{new_author}', Name: '{new_name}'.")
   389	            else:
   390	                await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –∞—É–¥–∏–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.")
   391	                logger.warning(f"Attempted to update non-existent audio ID {audio_id_to_edit} by user {user.id}.")
   392	        else:
   393	            logger.warning(f"User {user.id} provided new name '{new_name}' but missing other editing details.")
   394	            await update.message.reply_text("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∞—É–¥–∏–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å /edit –∑–∞–Ω–æ–≤–æ.")
   395	    
   396	    else:
   397	        logger.info(f"Received general text from {user.id}: '{update.message.text}'")
   398	
   399	async def inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   400	    """Handles inline queries to suggest cached voice/audio messages."""
   401	    query = update.inline_query.query.lower() # Convert query to lowercase for case-insensitive search
   402	    results = []
   403	
   404	    # Use the global cached_audios_data list
   405	    global cached_audios_data
   406	    
   407	    # Filter audios based on the query (match name or author)
   408	    filtered_audios = [
   409	        item for item in cached_audios_data
   410	        if query in item.get('name', '').lower() or query in item.get('author', '').lower() or not query
   411	    ]
   412	
   413	    for item in filtered_audios:
   414	        audio_name = item.get('name', 'Unknown Name')
   415	        author_name = item.get('author', 'Unknown Author')
   416	        
   417	        # Combine author and name into the title, separated by " - "
   418	        display_title = f"{author_name} - {audio_name}"
   419	        
   420	        if item.get('type') == "voice":
   421	            results.append(
   422	                InlineQueryResultCachedVoice(
   423	                    id=str(uuid4()), # Unique ID for each result
   424	                    voice_file_id=item['file_id'],
   425	                    title=display_title # Combined author and name
   426	                )
   427	            )
   428	        elif item.get('type') == "audio":
   429	            results.append(
   430	                InlineQueryResultCachedAudio(
   431	                    id=str(uuid4()), # Unique ID for each result
   432	                    audio_file_id=item['file_id'],
   433	                    title=display_title # Combined author and name
   434	                )
   435	            )
   436	
   437	    await update.inline_query.answer(results, cache_time=0)
   438	    logger.info(f"Inline query from {update.effective_user.first_name} ({update.effective_user.id}): '{query}' - {len(results)} results.")
   439	
   440	async def voices_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   441	    """Sends the first page of interactive audio list."""
   442	    # Pass update.message.message_id as the message_id to allow editing the initial command message
   443	    await send_paginated_audios(update.effective_chat.id, context, page=0, command_message_id=update.message.message_id)
   444	
   445	async def send_paginated_audios(chat_id: int, context: ContextTypes.DEFAULT_TYPE, page: int, command_message_id: int = None) -> None:
   446	    """Sends a page of audio files with pagination buttons."""
   447	    # The 'global cached_audios_data' line was removed from here as it's not needed for reading.
   448	    # The SyntaxError you observed indicates it might still be present in your deployed code.
   449	    # Please ensure this line is completely removed from your main.py file.
   450	    
   451	    # Delete the command message if it was passed
   452	    if command_message_id:
   453	        try:
   454	            await context.bot.delete_message(chat_id=chat_id, message_id=command_message_id)
   455	            logger.info(f"Deleted initial command message {command_message_id} in chat {chat_id}.")
   456	        except Exception as e:
   457	            logger.warning(f"Could not delete initial command message {command_message_id}: {e}")
   458	
   459	    # Delete previous audio messages and pagination message for this chat
   460	    if 'last_pagination_message_id' in context.chat_data and context.chat_data['last_pagination_message_id']:
   461	        last_pagination_message_id = context.chat_data.pop('last_pagination_message_id')
   462	        try:
   463	            await context.bot.delete_message(chat_id=chat_id, message_id=last_pagination_message_id)
   464	            logger.info(f"Deleted previous pagination message {last_pagination_message_id} in chat {chat_id}.")
   465	        except Exception as e:
   466	            logger.warning(f"Could not delete previous pagination message {last_pagination_message_id}: {e}")
   467	
   468	    if 'last_audio_message_ids' in context.chat_data and context.chat_data['last_audio_message_ids']:
   469	        for msg_id in context.chat_data.pop('last_audio_message_ids'):
   470	            try:
   471	                await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
   472	                logger.info(f"Deleted previous audio message {msg_id} in chat {chat_id}.")
   473	            except Exception as e:
   474	                logger.warning(f"Could not delete previous audio message {msg_id}: {e}")
   475	
   476	
   477	    if not cached_audios_data:
   478	        await context.bot.send_message(chat_id=chat_id, text="–ü–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∞—É–¥–∏–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
   479	        return
   480	
   481	    total_audios = len(cached_audios_data)
   482	    total_pages = (total_audios + AUDIOS_PER_PAGE - 1) // AUDIOS_PER_PAGE # Ceiling division
   483	    
   484	    # Adjust page number if it's out of bounds after deletion or initial call
   485	    if not (0 <= page < total_pages):
   486	        if total_pages > 0:
   487	            page = max(0, min(page, total_pages - 1)) # Adjust to valid page
   488	        else:
   489	            # If no audios left after adjustment, handle as empty
   490	            await context.bot.send_message(chat_id=chat_id, text="–ü–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∞—É–¥–∏–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
   491	            return
   492	
   493	    start_index = page * AUDIOS_PER_PAGE
   494	    end_index = min(start_index + AUDIOS_PER_PAGE, total_audios)
   495	    
   496	    audios_to_send = cached_audios_data[start_index:end_index]
   497	    
   498	    current_audio_message_ids = []
   499	
   500	    # Send the audio files for the current page
   501	    for item in audios_to_send:
   502	        # First, send a text message with Author and Name
   503	        text_message = f"–ê–≤—Ç–æ—Ä: {item.get('author', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä')}\n–ù–∞–∑–≤–∞–Ω–∏–µ: {item.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}"
   504	        text_msg = await context.bot.send_message(chat_id=chat_id, text=text_message)
   505	        current_audio_message_ids.append(text_msg.message_id)
   506	
   507	        # Then, send the audio file without any description/caption
   508	        try:
   509	            if item.get('type') == "voice":
   510	                audio_msg = await context.bot.send_voice(chat_id=chat_id, voice=item['file_id']) # No caption here
   511	            elif item.get('type') == "audio":
   512	                audio_msg = await context.bot.send_audio(chat_id=chat_id, audio=item['file_id']) # No caption here
   513	            current_audio_message_ids.append(audio_msg.message_id)
   514	        except Exception as e:
   515	            logger.error(f"Error sending audio (ID: {item['file_id']}): {e}")
   516	            error_msg = await context.bot.send_message(chat_id=chat_id, text=f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∞—É–¥–∏–æ '{item.get('name')}'. –í–æ–∑–º–æ–∂–Ω–æ, —Ñ–∞–π–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
   517	            current_audio_message_ids.append(error_msg.message_id)
   518	            # Optionally, remove the problematic audio from cached_audios_data and save_audio_metadata() here
   519	
   520	    # Create pagination buttons
   521	    keyboard = []
   522	    if page > 0:
   523	        keyboard.append(InlineKeyboardButton("‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"voices_page_{page - 1}"))
   524	    if page < total_pages - 1:
   525	        keyboard.append(InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", callback_data=f"voices_page_{page + 1}"))
   526	
   527	    reply_markup = InlineKeyboardMarkup([keyboard])
   528	    
   529	    # Always send a NEW pagination message at the end
   530	    pagination_text = f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page + 1} –∏–∑ {total_pages}"
   531	    new_pagination_message = await context.bot.send_message(
   532	        chat_id=chat_id,
   533	        text=pagination_text,
   534	        reply_markup=reply_markup
   535	    )
   536	    
   537	    # Store the message IDs for the current page in chat_data
   538	    context.chat_data['last_pagination_message_id'] = new_pagination_message.message_id
   539	    context.chat_data['last_audio_message_ids'] = current_audio_message_ids
   540	
   541	
   542	async def pagination_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
   543	    """Handles callback queries from pagination buttons."""
   544	    query = update.callback_query
   545	    await query.answer() # Acknowledge the callback query
   546	
   547	    callback_data = query.data
   548	    if callback_data.startswith("voices_page_"):
   549	        try:
   550	            page = int(callback_data.split("_")[2])
   551	            chat_id = query.message.chat.id
   552	            # The message_id of the button's message is the old pagination message
   553	            old_pagination_message_id = query.message.message_id
   554	            await send_paginated_audios(chat_id, context, page, command_message_id=None) # Pass None as command_message_id
   555	        except ValueError:
   556	            logger.error(f"Invalid pagination callback data: {callback_data}")
   557	            await query.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º.")
   558	
   559	
   560	# --- Health Check Server ---
   561	
   562	async def health_check(request):
   563	    """Responds to health check requests."""
   564	    logger.info("Health check requested.")
   565	    return web.Response(text="OK")
   566	
   567	# --- Application Runner ---
   568	
   569	async def run_server():
   570	    """Run both Telegram bot and health server."""
   571	    # Create application
   572	    application = Application.builder().token(TOKEN).build()
   573	    
   574	    # Add handlers
   575	    application.add_handler(CommandHandler("start", start))
   576	    application.add_handler(CommandHandler("add", add_audio_command))
   577	    application.add_handler(CommandHandler("list", list_audios_command))
   578	    application.add_handler(CommandHandler("delete", delete_audio_command))
   579	    application.add_handler(CommandHandler("move", move_audio_command))
   580	    application.add_handler(CommandHandler("edit", edit_audio_command))
   581	    application.add_handler(CommandHandler("voices", voices_command))
   582	    application.add_handler(MessageHandler(filters.VOICE | filters.AUDIO, handle_audio))
   583	    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_input))
   584	    application.add_handler(InlineQueryHandler(inline_query))
   585	    application.add_handler(CallbackQueryHandler(pagination_callback_handler, pattern=r'^voices_page_'))
   586	
   587	    # Load audio metadata from file at startup
   588	    load_audio_metadata()
   589	
   590	    # Start health server using aiohttp
   591	    app = web.Application()
   592	    app.router.add_get('/healthz', health_check)
   593	    runner = web.AppRunner(app)
   594	    await runner.setup()
   595	    site = web.TCPSite(runner, '0.0.0.0', HEALTH_CHECK_PORT)
   596	    await site.start()
   597	    logger.info(f"Health check server started on port {HEALTH_CHECK_PORT}")
   598	    
   599	    # Start Telegram bot
   600	    await application.initialize()
   601	    await application.start()
   602	    await application.updater.start_polling()
   603	    logger.info("Telegram bot started polling.")
   604	    
   605	    # Keep running forever
   606	    while True:
   607	        await asyncio.sleep(3600)
   608	
   609	if __name__ == "__main__":
   610	    # Create storage directory if it doesn't exist (this will be on the mounted volume)
   611	    os.makedirs(AUDIO_STORAGE, exist_ok=True)
   612	    logger.info(f"Ensured '{AUDIO_STORAGE}' directory exists.")
   613	    
   614	    # Ensure BOT_TOKEN is set
   615	    if not TOKEN:
   616	        logger.error("BOT_TOKEN environment variable is not set. Please set it before running the bot.")
   617	        exit(1)
   618	
   619	    # Run the main server function
   620	    try:
   621	        asyncio.run(run_server())
   622	    except KeyboardInterrupt:
   623	        logger.info("Bot stopped by user (KeyboardInterrupt).")
   624	    except Exception as e:
   625	        logger.error(f"An unexpected error occurred: {e}")
